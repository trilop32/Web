<!DOCTYPE html>

<html lang="ru" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    <title>Процессоры</title>
    <link rel="stylesheet" href="style2.css" />
</head>
<body>
    <h2>Понятие архитектуры</h2>
    <h3>Архитектура как совместимость с кодом</h3>
    <p>
        Наверняка вы часто встречались с термином «x86», или «Intel-совместимый процессор» (или «IBM PC compatible» — но это уже по отношению к компьютеру).
        Иногда также встречается термин «Pentium-совместимый» (почему именно Pentium — вы поймете сами чуть позже). Что скрывается за всеми этими названиями?
        На данный момент наиболее корректно с точки зрения авторов выглядит следующая простая формулировка: современный x86-процессор — это процессор,
        способный корректно исполнять машинный код архитектуры x86-64 (архитектура 32-битных процессоров Intel, дополненная 64-битными расширениями от AMD).
        В первом приближении современный x86 — это код, исполняемый процессором i80386 (известным в народе как «386-й»), окончательно же основной набор команд
        32-битной архитектуры IA32 сформировался с выходом процессора Intel Pentium Pro (с очень незначительным дополнениями в следующих процессорах).
        Что означает «основной набор» и какие есть еще? Для начала ответим на первую часть. «Основной» в данном случае означает то, что с помощью исключительно
        этого набора команд может быть написана любая программа для процессора архитектуры x86.
    </p>
    <p>
        Кроме того, у архитектуры IA32 существуют «официальные» расширения (дополнительные наборы команд) от разработчика самой архитектуры, компании Intel:
        MMX, многочисленные SSE (вплоть до 4.2) и AVX. Также существуют «неофициальные» (не от Intel) расширенные наборы команд: EMMX, 3DNow!, Extended 3DNow!,
        SSE4.a и XOP — их разработала компания AMD. Впрочем, «официальность» и «неофициальность» в данном случае понятие относительное — де-факто всё сводится
        к тому, что некоторые расширения набора команд Intel как разработчик изначального набора признаёт, а некоторые — нет, разработчики же программного
        обеспечения используют то, что им лучше всего подходит. В отношении расширенных наборов команд существует правило хорошего тона: прежде чем их
        использовать, программа должна проверить, поддерживает ли их процессор. Иногда отступления от этого правила встречаются (и могут приводить к
        неправильному функционированию программ), но объективно это является проблемой некорректно написанной программы, а не процессора.
    </p>
    <p>
        Для чего предназначены дополнительные наборы команд? В первую очередь — для увеличения быстродействия при выполнении наиболее частых операций.
        Одна команда из дополнительного набора, как правило, выполняет действие, для которого понадобилась бы небольшая процедура, состоящая из команд
        основного набора, причём специальная команда выполняется процессором быстрее, чем заменяющая её последовательность. Однако в 99% случаев ничего такого,
        чего нельзя было бы сделать с помощью основных команд, команды из дополнительного набора также не делают. Таким образом, упомянутая выше программная
        проверка поддержки дополнительных наборов команд процессором должна выполнять очень простую функцию: если, например, процессор поддерживает SSE — значит,
        считать будем быстро и с помощью команд из набора SSE. Если нет — будем считать медленнее, с помощью команд из основного набора. Корректно написанная
        программа обязана действовать именно так. Впрочем, сейчас практически никто не проверяет у процессора наличие поддержки MMX, т.к. все CPU, вышедшие за
        последние 10 лет, этот набор поддерживают гарантированно. Для справки приведём табличку, на которой обобщена информация о поддержке различных расширенных
        наборов команд различными десктопными (предназначенными для настольных ПК) и некоторыми мобильными процессорами.
    </p>
    <table>
        <caption>Таблица 1 - Сравнение процессоров</caption>
        <tr>
            <th>Процессор</th>
            <th>Год выпуска</th>
            <th>x86-64</th>
            <th>PPro</th>
            <th>MMX</th>
            <th>Версия SSE</th>
            <th>3DNow!</th>
        </tr>
        <tr >
            <td style="background-color: rebeccapurple" colspan="7"><i>Процессоры Intel</i></td>
        </tr>
        <tr>
            <td>Pentium</td>
            <td>1993</td>
            <td class="NA"></td>
            <td class="NA"></td>
            <td class="NA"></td>
            <td class="NA"></td>
            <td class="NA"></td>
        </tr>
        <tr>
            <td>Pentium Pro</td>
            <td>1995</td>
            <td></td>
            <td class="Present">X</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium MMX</td>
            <td rowspan="2">1997</td>
            <td></td>
            <td></td>
            <td>X</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium II</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron</td>
            <td>1998</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium III</td>
            <td>1999</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>1</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium 4</td>
            <td rowspan="2">2000</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>2</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>1</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron</td>
            <td>2002</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>2</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium M</td>
            <td>2003</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>2</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium 4</td>
            <td rowspan="2">2004</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>3</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron D</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>3</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium D, EE</td>
            <td rowspan="2">2005</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">3</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron D</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron</td>
            <td rowspan="4">2006</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>3S</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron M</td>
            <td rowspan="2"></td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">3</td>
            <td></td>
        </tr>
        <tr>
            <td>Core Solo, Duo</td>
            <td></td>
        </tr>
        <tr>
            <td>Core 2</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>3S</td>
            <td></td>
        </tr>
        <tr>
            <td>Core 2</td>
            <td rowspan="4">2007</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.1</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron M</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">3S</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium (DC)</td>
            <td></td>
        </tr>
        <tr>
            <td>Pentium (DC, M)</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>3</td>
            <td></td>
        </tr>
        <tr>
            <td>Atom</td>
            <td rowspan="3">2008</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">3S</td>
            <td></td>
        </tr>
        <tr>
            <td>Celeron (DC)</td>
            <td></td>
        </tr>
        <tr>
            <td>Core i7</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.2</td>
            <td></td>
        </tr>
        <tr>
            <td>Core i3, i5</td>
            <td>2009</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.2</td>
            <td></td>
        </tr>
        <tr>
            <td>Core i9</td>
            <td>2010</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.2</td>
            <td></td>
        </tr>
        <tr>
            <td style="background-color: rebeccapurple" colspan="7"><i> Процессоры AMD</i></td>
        </tr>
        <tr>
            <td>K5</td>
            <td>1996</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>K6</td>
            <td>1997</td>
            <td></td>
            <td></td>
            <td>X</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>K6-3D, K6-2+</td>
            <td>1998</td>
            <td></td>
            <td></td>
            <td>X</td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>K6-III</td>
            <td rowspan="2">1999</td>
            <td></td>
            <td></td>
            <td>X</td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>Duron</td>
            <td>2000</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon XP</td>
            <td rowspan="3">2001</td>
            <td rowspan="3"></td>
            <td rowspan="3">X</td>
            <td rowspan="3">X</td>
            <td rowspan="3">1</td>
            <td rowspan="3">X</td>
        </tr>
        <tr>
            <td>Athlon 4 (M)</td>
        </tr>
        <tr>
            <td>Duron</td>
        </tr>
        <tr>
            <td>Athlon 64</td>
            <td>2003</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>2</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Semprom</td>
            <td>2004</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>1 (2)</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon XP-M</td>
            <td rowspan="5">2005</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>2</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Sempron</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>2 (3)</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon (64) X2</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">3</td>
            <td rowspan="2">X</td>
        </tr>
        <tr>
            <td>Turion (M)</td>
        </tr>
        <tr>
            <td>Sempron (M)</td>
            <td></td>
            <td>X</td>
            <td>X</td>
            <td>3</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Phenom</td>
            <td>2007</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.a</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon X2</td>
            <td>2008</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>4.a</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Athlon Neo</td>
            <td rowspan="3">2009</td>
            <td>X</td>
            <td>X</td>
            <td>X</td>
            <td>3</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Phenom II</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">X</td>
            <td rowspan="2">4.a</td>
            <td rowspan="2">X</td>
        </tr>
        <tr>
            <td>Athlon II X3, X4</td>
        </tr>
    </table>
    <p>
        Примечания:<br>
        PPro — означает наличие всех общих команд;<br>
        Версия SSE — номер последней поддерживаемой версии, подразумевая и все предыдущие;<br>
        Ряд SSE: SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2;<br>
        Для процессоров AMD наличие SSE4.a означает поддержку только SSE, SSE2, SSE3 и SSE4.a;<br>
        (M) — мобильная модель, даже если явно в имени не указано;<br>
        (DC) — двухядерный процессор, указано в индексе модели.<br>
    </p>
    <p>
        На данный момент всё популярное десктопное программное обеспечение (операционные системы Windows и Linux, офисные пакеты, компьютерные игры, и прочее)
        разрабатывается именно для x86-процессоров. Оно выполняется (за исключением «дурно воспитанных» программ) на любом x86-процессоре, независимо от того,
        кто его произвёл. Поэтому вместо ориентированных на разработчика изначальной архитектуры терминов «Intel-совместимый» или «Pentium-совместимый», стали употреблять нейтральное название: «x86-совместимый процессор», «процессор с архитектурой x86». В данном случае под «архитектурой» понимается архитектура системы команд (ISA,<a href="https://en.wikipedia.org/w/index.php?title=Instruction_set_architecture&utm_source=ixbtcom">Instruction Set Architecture</a>) — совместимость с определённым набором команд с точки зрения программиста. Есть и другая трактовка того же термина.
    </p>
    <h3>Архитектура как характеристика семейства процессоров</h3>
    <p>
        «Железячники» — люди, работающие в основном не с программным обеспечением, а с аппаратным — под «архитектурой» понимают несколько другое (правда,более корректно то, что они называют «архитектурой», называется «микроархитектурой», но приставку «микро» частенько опускают).Для них «архитектура CPU» — это некий набор свойств, присущий целому семейству процессоров, как правило, выпускаемому в течение многих лет (иначе говоря — их организация и «внутренняя конструкция»). Например, любой специалист по x86 CPU вам скажет, что процессор с ALU, работающими на удвоенной частоте, QDR-шиной, Trace cache, и, возможно, поддержкой технологии Hyper-Threading — это «процессор архитектуры NetBurst» (не пугайтесь незнакомых терминов — все нужные будут разъяснены чуть позже). Таким образом, понятие «архитектуры» применительно к процессорам двойственно: под ним может пониматься как совместимость с единым набором команд, так и совокупность аппаратных решений, присущих определённой достаточно широкой группе процессоров.
    </p>
    <h3>64-битные расширения классической x86 (IA32) архитектуры</h3>
    <p>
        В 2003 г. сначала AMD, а через год — и Intel, анонсировали практически идентичные технологии (впрочем, AMD предпочитает называть это архитектурой), благодаря которым классические x86 (IA32) CPU получили статус 64-битных. В случае с AMD данная технология получила наименование «AMD64», в случае с Intel — сначала «EM64T», а теперь Intel 64. Впрочем, сегодня часто указывают нейтральное «x86-64» — как общее обозначение всех 64-битных расширений архитектуры x86, не привязанное к зарегистрированным торговым маркам. Употребление одного из трёх приведённых наименований зависит больше от личных предпочтений употребляющего, чем от фактических различий — ибо различия между AMD64 и EM64T умещаются на кончике очень тонкой иглы. Так или иначе, всё сводится к следующему: все целочисленные регистры (общего назначения) стали вместо 32-битных 64-битными, число регистров (и общих, и векторных) удвоилось, 32-битные команды x86-кода получили свои 64-битные аналоги, а объём адресуемой памяти (и физической, и виртуальной) многократно увеличился (за счёт того, что логический адрес приобрёл вместо 32-битного 64-битный формат). Количество маркетинговых спекуляций на тему «64-битности» превысило все разумные пределы, поэтому следует рассмотреть достоинства данного нововведения.
    </p>
    <p>
        Что не изменилось? В первую очередь — быстродействие процессоров. Вопиющей глупостью будет считать, что один и тот же процессор при переходе из привычного 32-битного в 64-битный режим (а 32-битный режим все нынешние x86 CPU поддерживают в обязательном порядке) станет работать вдвое быстрее. Разумеется, в некоторых случаях ускорение от использования 64-битной целочисленной арифметики может присутствовать — но количество этих случаев сильно ограничено, и большинства современного пользовательского программного обеспечения они никак не касаются. Кстати: а почему мы употребили термин «64-битная целочисленная арифметика»? А потому, что блоки операций с плавающей точкой (см. ниже) во всех x86-процессорах уже давным-давно не 32-битные. И даже не 64-битные. Классический вещественный вычислитель, окончательно ставший частью CPU ещё во времена старого доброго 32-битного Intel Pentium* — уже был 80-битным (и до сих пор таков). Векторные операнды команд SSE (с любой цифрой) — и вовсе 128-битные! В этом плане архитектура x86 достаточно парадоксальна: притом, что формально процессоры данной архитектуры достаточно долгое время оставались 32-битными — разрядность тех блоков, где «большая битность» была реально необходима — наращивалась совершенно независимо от остальных (<a href="https://www.ixbt.com/cpu/cpu-bitness.shtml">более подробно о проблеме разрядности процессоров можно почитать в отдельном материале</a>). Например, процессоры AMD Athlon XP и Intel Pentium 4 «Northwood» совмещали в себе блоки, работающие с 32-битными, 80-битными, и 128-битными операндами. 32-битными оставались лишь основной набор команд (унаследованный от первого процессора архитектуры IA32 — Intel 386) и адресация памяти (максимум 4 гигабайта, если не считать «эквилибристического выверта» от Intel — <a href="https://ru.wikipedia.org/wiki/PAE?utm_source=ixbtcom">Physical Address Extension</a>, позволявшего «32-битным» процессорам использовать 36(!)-битную адресацию).
    </p>
    <ul style="background-color: rgba(0,0,0,0.8)">
        * &ndash;
        <i> первым x86 CPU, в который был интегрирован FPU (ранее он устанавливался на плату в качестве отдельного чипа), стал процессор предыдущего поколения — i486DX. Но в линейке i486 всё-таки присутствовал i486SX, в состав которого FPU не входил. Начиная с Pentium, Intel больше не выпускала x86 CPU без FPU, и эту моду быстро подхватили все остальные производители</i>.
    </ul>
    <p>
        Таким образом, то, что процессоры AMD и Intel стали «формально 64-битными», на практике принесло нам лишь три усовершенствования: появление команд для работы с 64-битными целыми числами, увеличение количества и/или разрядности регистров, и увеличение максимального объёма адресуемой памяти. Заметим: реальной пользы этих нововведений (особенно третьего!) никто не отрицает. Равно как никто не отрицает заслуг компании AMD в продвижении идеи «осовременивания» (за счёт введения 64-битности) x86-процессоров. Мы лишь хотим предостеречь от чрезмерных ожиданий: не стоит надеяться на то, что компьютер, покупавшийся «в ценовом классе ВАЗа», от установки 64-битного программного обеспечения станет «лихим Мерседесом». Чудес на свете не бывает...
    </p>




    <h2>Процессорное ядро</h2>
    <h3>О многоядерности (многопроцессорности) как концепции</h3>
    <p>
        <img class="img" alt="Схема" src="https://www.ixbt.com/cpu/images/cpu-digest-2009/1-th-1-cpu.png" title="Классическая одноядерная (однопроцессорная) схема: в памяти находится код нескольких программ («кирпичики» разного цвета), но в один момент времени процессор выполняет код только одной из них">
        <img class="img3" src="https://www.ixbt.com/cpu/images/cpu-digest-2009/4-cpu-mb.png" title="4-процессорная системная плата, в каждый сокет которой можно установить 6-ядерный процессор. В результате мы получим 24-ядерную x86-систему.">
        Прежде, чем мы начнём описывать особенности многоядерных систем, нужно вначале объяснить, зачем вообще они нужны, и как за счёт большего количества ядер и/или процессоров может достигаться  положительный эффект. В данном случае мы для простоты считаем, что система, собранная на базе одного процессора с двумя ядрами, практически идентична по функционалу системе на базе двух процессоров с одним ядром — если ядра в обоих случаях идентичны*. Более подробное разъяснение можно прочитать в отдельном, более сложном материале, но хотя бы схематически описать ситуацию просто необходимо. Всё нижесказанное относится к концепции SMP (<a href="https://ru.wikipedia.org/w/index.php?title=%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C&utm_source=ixbtcom">Symmetric Multiprocessing</a>, cимметричная многопроцессорность), т.к. пока на x86 прижился именно этот вариант. Он требует, чтобы при любом числе процессоров (строго говоря — процессорных ядер) в системе они все были одинаковые, каждый может быть заменен любым другим, и все они осуществляют доступ к одному и тому же массиву памяти.
    </p>
    <p>
        <i>Раньше многоядерный процессор на массовом рынке был мечтой практически неосуществимой, поэтому в тех отраслях, где требовалась высокая производительность в специфических задачах, использовались системы не многоядерные, а многопроцессорные. Вместо того, чтобы интегрировать N ядер в один чип — на системную плату устанавливали N разъёмов, и в них — N одноядерных процессоров. Условно, современный десктоп на N-ядерном процессоре, можно приравнять к N-процессорной системе. Впрочем, многопроцессорные системы есть и сейчас — для тех, кого не устраивает максимально возможное количество ядер в одном CPU. Так, например, если вам нужна 16-процессорная (16-ядерная) система — то ввиду отсутствия 16-ядерных x86-процессоров (пока, на 2009 г.…), вам придётся согласиться на 4-процессорную систему, в которой у каждого процессора будет по 4 ядра.</i>
    </p>
    <p>
        Итак, наш главный вопрос: для чего всё это нужно? Каким образом за счёт увеличения количества ядер (процессоров) увеличивается быстродействие? Сразу расскажем, какой основной вопрос возникает при более детальном ознакомлении с многоядерными (многопроцессорными) системами: <i>«Почему быстродействие увеличивается в разных случаях по-разному, а иногда не увеличивается вовсе?»</i> Проще всего разъяснить это на примере простой и понятной аналогии с неким количеством работы, и неким количеством людей. Рассмотрим два самых распространённых варианта.
    </p>
    <p>
        <i><b>Вариант №1</b></i>: несколько совершенно независимых друг от друга задач. Например, мы находимся в загородном доме, и нам необходимо наколоть дров и выкосить газон. Если у нас в распоряжении один человек — он будет вынужден сделать сначала одно дело, а потом другое, либо делать их параллельно, переключаясь между ними — но всё равно в один конкретный момент времени он будет занят чем-то одним. Если же есть два человека — то один может заняться колкой дров, а другой — косить газон. Заметьте: <i>сами по себе задачи не стали выполняться быстрее — но мы экономим время за счёт того, что они выполняются параллельно</i>. Продолжив аналогию, вы легко поймёте основной недостаток наращивания в данной ситуации количества людей  до бесконечности (а они у нас олицетворяют процессорные ядра или одноядерные процессоры): рано или поздно для ещё одного человека просто не найдётся работы. Или ресурсов: например, колоть дрова можно и вдвоём — но что делать, если у нас всего один топор?
    </p>
    <p>
        <i><b>Вариант №2</b></i>: одна частично или полностью распараллеливаемая задача. Почти идеально распараллеливаемая задача (при условии, как уже было упомянуто выше, наличия должного количества ресурсов) — это та же колка дров, или, например, мытьё полов. Каждому в руки по швабре и ведру, каждому свой участок пола — и вперёд! Вы, правда, наверняка заметите, на основании банального житейского опыта, что ещё и задача должна быть соответствующего масштаба: хорошо мыть полы вчетвером в большом доме, но совершенно бессмысленно — в одной комнатушке. В случае с многоядерностью всё совершенно аналогично: быстро выполняемая задача, даже если она хорошо параллелится, вызывает давно известный эффект: согласование действий между выполняющими работу начинает занимать время, сопоставимое с временем выполнения самой работы каждым исполнителем. Русская пословица «у семи нянек дитя без глаза» примерно характеризует данную ситуацию.
    </p>
    <p>
        Более сложный случай — например, варка борща. Конечно, хозяйка может поручить кому-то почистить овощи, кому-то нарезать, и т.д., но всё равно на некотором этапе у нас начнётся достаточно длительный процесс (собственно варки), в котором участие более чем одного человека совершенно не требуется. Это и есть частично распараллеливаемая задача: некоторые её этапы могут выполняться параллельно, а некоторые — нет. Совершенно очевидно, что <i>даже если выделить на выполнение этой задачи двух людей, в 2 раза её выполнение не ускорится</i> (а если четырёх — то в случае с борщом, четвёртый может оказаться в большинстве случаев лишним). И у многоядерных процессоров на частично распараллеливаемой задаче не все ядра могут задействоваться одновременно всё время. А значит, некоторые из них как минимум иногда будут простаивать.
    </p>
    <p>
        Подытожим: добавление ещё одного ядра не всегда приводит к ускорению, а даже если и приводит — то не всегда настолько, сколько можно было бы ожидать в идеальном случае. Фактически, всё зависит от решаемых задач (используемых программ). Некоторые задачи параллелятся хорошо, некоторые — не очень, некоторые не параллелятся вообще. Почти идеально в большинстве случаев параллелятся две независимых задачи, но… для этого нужно, чтобы у вас достаточно часто возникала потребность решать несколько независимых задач одновременно! Говоря конкретней, двухъядерный процессор на программах обычного пользователя в среднем получит ускорение примерно раза в полтора, а 4-ядерный — примерно в два по сравнению с одноядерным. А вот при запуске «профессиональных» программ кратность ускорения часто почти равна числу ядер.
    </p>
    <h3>Число ядер и технология Hyper-Threading</h3>
    <p>
        <img class="imgg" src="https://www.ixbt.com/cpu/images/cpu-digest-2009/2-th-2-cpu.png" title="Многоядерная (многопроцессорная) система: благодаря наличию двух ядер (процессоров), можно одновременно исполнять код двух программ">
        Первое, что надо сказать о ядрах — в одном процессоре их бывает много. В вашем их, скорее всего, не менее двух, а вообще их может быть от 1 до 6 (скоро — и больше). Все ядра одинаковые, но кроме них в процессоре есть и обслуживающие их общие блоки — общий кэш, контроллер памяти и шины обмена с другими процессорами и/или с чипсетом. В новейших процессорах к этому списку скоро добавятся и специализированные ядра, например, для 3D-графики и декодирования видео. Когда говорят об устройстве ядер, то имеют ввиду каждое ядро многоядерного процессора (даже если говорится «ядро» в единственном числе).
    </p>
    <p>
        Как было сказано, у многоядерности есть ограничения по увеличению производительности. Когда задачи или их части выполняются параллельно, ядра конкурируют за доступ к общим блокам. Например, если запустить две задачи, сильно зависящие от пропускной способности памяти, и которым не хватит объёма кэша каждого ядра, то производительности общего для ядер кэша, а также контроллера памяти может быть недостаточно, чтобы насытить сразу два ядра. В результате они оба будут простаивать до половины времени — реальное увеличение скорости по сравнению с однопоточным исполнением может быть околонулевым. Противоположная ситуация, когда программы оптимизированы под многоядерные процессоры и не перегружают разделяемые ресурсы, выглядит примерно так: процессор исполняет столько потоков, сколько у него ядер, причём каждый поток в основном использует блоки своего ядра, а общение ядер между собой, а также с памятью достаточно редко, чтобы даже исполнение нескольких потоков не перегружало общие элементы процессора и не приводило к задержкам работы ядер. Подобрать по такому критерию несколько разных программ весьма сложно, а вот оптимизировать одну — удаётся куда чаще. Именно в таких случаях и удаётся получить то, что называется линейным ростом производительности от числа потоков (фактически — ядер): 2 ядра работают вдвое быстрее одного, 4 — вдвое быстрее двух, и т.д.. Всё вышесказанное касается и многопроцессорных систем, где число ядер каждого CPU надо умножить на число последних.
    </p>
    <p>
        <img class="imgg" src="https://www.ixbt.com/cpu/images/cpu-digest-2009/2-th-1-cpu.png" title="Процессор с поддержкой Hyper-Threading: на одном физическом ядре одновременно выполняется код двух приложений">
        Дополнительную сложность вносит поддержка некоторыми процессорами технологии Hyper-Threading (гиперпоточности). Она позволяет одному ядру работать за два — хотя и не так эффективно, как реально существующая пара ядер, зато куда дешевле. При этом операционная система сообщает о процессоре с вдвое большим числом ядер, поскольку видит число ядер логических (по максимальному количеству одновременно запускаемых программ), а не физических (по числу реально выполняемых). Изменение производительности может быть от почти незаметного замедления до внушительного (20-50 %) ускорения и сильно зависит от набора исполняемых программ, а в среднем же ускорение равно 10-15%. К сожалению, чем лучше программа оптимизирована под настоящую многоядерность, тем меньше она выиграет от «виртуальной» за счёт Hyper-Threading.
        <br>
        <br>
        <br>
        <br>
    </p>
    <h4>
        <a  href="#">Наверх</a>
    </h4>
</body>
</html>